#Requires AutoHotkey v2.0
#SingleInstance Force

; ==================== CONFIGURATION ====================
class Config {
    ; REASONABLE DEFAULTS - Now in PIXELS instead of scale
    
    ; Detection settings
    static WiggleThreshold := 350        ; Reasonable movement threshold
    static TimeWindow := 750             ; 3/4 second window
    static MinWiggleCount := 3           ; 3 wiggles minimum
    static MinWiggleDistance := 30       ; Reasonable minimum distance
    static MaxSingleDirection := 500     ; Prevents false positives
    static RequireAlternating := true    ; Keep alternating requirement
    
    ; Display settings - IN PIXELS!
    static EnlargeSize := 64             ; Target size when wiggling (pixels)
    static RestingSize := 32             ; Normal cursor size (pixels)
    static MinimumSize := 1              ; Minimum cursor size (pixels)
    static MaximumSize := 256            ; Maximum cursor size (pixels)
    static ResetSize := 32               ; Size to reset to (configurable)
    static EnlargeDuration := 500        ; Hold enlarged for half second AFTER wiggling stops
    static InterpolationTime := 800      ; MUCH slower growth (was 200)
    static ShrinkTime := 1000            ; Slower shrink back (was 250)
    static SmoothShrink := true
    static MaintainMaxWhileWiggling := true
    static ContinuousGrowth := true      ; Keep growing while wiggling
    static GrowthIncrement := 2          ; Pixels to grow per wiggle detection
    
    ; Performance settings - OPTIMIZED
    static CheckInterval := 30           ; Check every 30ms (balanced)
    static UpdateInterval := 50          ; Update every 50ms (smooth)
    static Enabled := true
    
    ; Visual Effects - OFF by default for performance
    static PulseOnWiggle := false        ; OFF - CPU intensive
    static PulseSpeed := 500
    static RainbowMode := false          ; OFF - distracting
    static ChaosMode := false            ; OFF - unpredictable
    static RandomSizeMin := 16           ; Minimum random size in pixels
    static RandomSizeMax := 128          ; Maximum random size in pixels
    
    ; Advanced Detection - OFF for performance
    static CircularWiggleDetection := false  ; OFF - CPU intensive
    static DiagonalWiggleDetection := false  ; OFF - CPU intensive
    static PatternMemory := 5                ; Reasonable memory
    static AdaptiveSensitivity := false      ; OFF - CPU intensive
    
    ; File paths
    static ConfigFile := A_ScriptDir . "\wiggle_config.ini"
    
    ; Save configuration
    static Save() {
        try {
            ; Detection settings
            IniWrite(this.WiggleThreshold, this.ConfigFile, "Detection", "WiggleThreshold")
            IniWrite(this.TimeWindow, this.ConfigFile, "Detection", "TimeWindow")
            IniWrite(this.MinWiggleCount, this.ConfigFile, "Detection", "MinWiggleCount")
            IniWrite(this.MaxSingleDirection, this.ConfigFile, "Detection", "MaxSingleDirection")
            IniWrite(this.RequireAlternating, this.ConfigFile, "Detection", "RequireAlternating")
            IniWrite(this.MinWiggleDistance, this.ConfigFile, "Detection", "MinWiggleDistance")
            IniWrite(this.CircularWiggleDetection, this.ConfigFile, "Detection", "CircularWiggleDetection")
            IniWrite(this.DiagonalWiggleDetection, this.ConfigFile, "Detection", "DiagonalWiggleDetection")
            IniWrite(this.PatternMemory, this.ConfigFile, "Detection", "PatternMemory")
            IniWrite(this.AdaptiveSensitivity, this.ConfigFile, "Detection", "AdaptiveSensitivity")
            
            ; Display settings - now in pixels
            IniWrite(this.EnlargeSize, this.ConfigFile, "Display", "EnlargeSize")
            IniWrite(this.RestingSize, this.ConfigFile, "Display", "RestingSize")
            IniWrite(this.MinimumSize, this.ConfigFile, "Display", "MinimumSize")
            IniWrite(this.MaximumSize, this.ConfigFile, "Display", "MaximumSize")
            IniWrite(this.ResetSize, this.ConfigFile, "Display", "ResetSize")
            IniWrite(this.EnlargeDuration, this.ConfigFile, "Display", "EnlargeDuration")
            IniWrite(this.InterpolationTime, this.ConfigFile, "Display", "InterpolationTime")
            IniWrite(this.SmoothShrink, this.ConfigFile, "Display", "SmoothShrink")
            IniWrite(this.ShrinkTime, this.ConfigFile, "Display", "ShrinkTime")
            IniWrite(this.MaintainMaxWhileWiggling, this.ConfigFile, "Display", "MaintainMaxWhileWiggling")
            IniWrite(this.ContinuousGrowth, this.ConfigFile, "Display", "ContinuousGrowth")
            IniWrite(this.GrowthIncrement, this.ConfigFile, "Display", "GrowthIncrement")
            
            ; Visual Effects
            IniWrite(this.PulseOnWiggle, this.ConfigFile, "VisualEffects", "PulseOnWiggle")
            IniWrite(this.PulseSpeed, this.ConfigFile, "VisualEffects", "PulseSpeed")
            IniWrite(this.RainbowMode, this.ConfigFile, "VisualEffects", "RainbowMode")
            IniWrite(this.ChaosMode, this.ConfigFile, "VisualEffects", "ChaosMode")
            IniWrite(this.RandomSizeMin, this.ConfigFile, "VisualEffects", "RandomSizeMin")
            IniWrite(this.RandomSizeMax, this.ConfigFile, "VisualEffects", "RandomSizeMax")
            
            ; General settings
            IniWrite(this.Enabled, this.ConfigFile, "General", "Enabled")
            IniWrite(this.CheckInterval, this.ConfigFile, "General", "CheckInterval")
            IniWrite(this.UpdateInterval, this.ConfigFile, "General", "UpdateInterval")
            
            return true
        } catch {
            return false
        }
    }
    
    ; Load configuration
    static Load() {
        try {
            if (!FileExist(this.ConfigFile)) {
                this.Save() ; Create default config
                return
            }
            
            ; Load with reasonable defaults as fallback
            this.WiggleThreshold := Integer(IniRead(this.ConfigFile, "Detection", "WiggleThreshold", 350))
            this.TimeWindow := Integer(IniRead(this.ConfigFile, "Detection", "TimeWindow", 750))
            this.MinWiggleCount := Integer(IniRead(this.ConfigFile, "Detection", "MinWiggleCount", 3))
            this.MaxSingleDirection := Integer(IniRead(this.ConfigFile, "Detection", "MaxSingleDirection", 500))
            this.RequireAlternating := IniRead(this.ConfigFile, "Detection", "RequireAlternating", "1") = "1"
            this.MinWiggleDistance := Integer(IniRead(this.ConfigFile, "Detection", "MinWiggleDistance", 30))
            this.CircularWiggleDetection := IniRead(this.ConfigFile, "Detection", "CircularWiggleDetection", "0") = "1"
            this.DiagonalWiggleDetection := IniRead(this.ConfigFile, "Detection", "DiagonalWiggleDetection", "0") = "1"
            this.PatternMemory := Integer(IniRead(this.ConfigFile, "Detection", "PatternMemory", 5))
            this.AdaptiveSensitivity := IniRead(this.ConfigFile, "Detection", "AdaptiveSensitivity", "0") = "1"
            
            ; Load pixel-based settings
            this.EnlargeSize := Integer(IniRead(this.ConfigFile, "Display", "EnlargeSize", 64))
            this.RestingSize := Integer(IniRead(this.ConfigFile, "Display", "RestingSize", 32))
            this.MinimumSize := Integer(IniRead(this.ConfigFile, "Display", "MinimumSize", 1))
            this.MaximumSize := Integer(IniRead(this.ConfigFile, "Display", "MaximumSize", 256))
            this.ResetSize := Integer(IniRead(this.ConfigFile, "Display", "ResetSize", 32))
            this.EnlargeDuration := Integer(IniRead(this.ConfigFile, "Display", "EnlargeDuration", 500))
            this.InterpolationTime := Integer(IniRead(this.ConfigFile, "Display", "InterpolationTime", 800))
            this.SmoothShrink := IniRead(this.ConfigFile, "Display", "SmoothShrink", "1") = "1"
            this.ShrinkTime := Integer(IniRead(this.ConfigFile, "Display", "ShrinkTime", 1000))
            this.MaintainMaxWhileWiggling := IniRead(this.ConfigFile, "Display", "MaintainMaxWhileWiggling", "1") = "1"
            this.ContinuousGrowth := IniRead(this.ConfigFile, "Display", "ContinuousGrowth", "1") = "1"
            this.GrowthIncrement := Integer(IniRead(this.ConfigFile, "Display", "GrowthIncrement", 2))
            
            this.PulseOnWiggle := IniRead(this.ConfigFile, "VisualEffects", "PulseOnWiggle", "0") = "1"
            this.PulseSpeed := Integer(IniRead(this.ConfigFile, "VisualEffects", "PulseSpeed", 500))
            this.RainbowMode := IniRead(this.ConfigFile, "VisualEffects", "RainbowMode", "0") = "1"
            this.ChaosMode := IniRead(this.ConfigFile, "VisualEffects", "ChaosMode", "0") = "1"
            this.RandomSizeMin := Integer(IniRead(this.ConfigFile, "VisualEffects", "RandomSizeMin", 16))
            this.RandomSizeMax := Integer(IniRead(this.ConfigFile, "VisualEffects", "RandomSizeMax", 128))
            
            this.Enabled := IniRead(this.ConfigFile, "General", "Enabled", "1") = "1"
            this.CheckInterval := Integer(IniRead(this.ConfigFile, "General", "CheckInterval", 30))
            this.UpdateInterval := Integer(IniRead(this.ConfigFile, "General", "UpdateInterval", 50))
            
        } catch {
            ; Use defaults on error
        }
    }
}

; ==================== GLOBALS ====================
global SYSTEM_ORIGINAL_SIZE := 32
global ABSOLUTE_MAX_SIZE := 32768     ; Windows absolute maximum
global ABSOLUTE_MIN_SIZE := 1          ; Windows absolute minimum

global currentCursorSize := 32
global targetCursorSize := 32
global currentWiggleSize := 32        ; Track current size during wiggling
global isAnimating := false
global isEnlarged := false
global isCurrentlyWiggling := false   ; Track active wiggling state
global wiggleDetectorInstance := ""
global lastCursorUpdate := 0
global wiggleCount := 0               ; Track consecutive wiggles for growth
global lastWiggleDetectionTime := 0   ; Track when we last detected a wiggle

; Critical sections for preventing timer conflicts
global isCheckingMouse := false
global isUpdatingCursor := false
global lastCheckTime := 0
global lastUpdateTime := 0

; ==================== MAIN DETECTION CLASS ====================
class WiggleDetector {
    __New() {
        this.Reset()
        
        MouseGetPos(&x, &y)
        this.lastX := x
        this.lastY := y
        
        ; Store timer references
        this.checkTimer := ""
        this.updateTimer := ""
        this.shrinkTimer := ""
        
        ; Start the timers
        this.StartTimers()
    }
    
    StartTimers() {
        ; Stop any existing timers first
        this.StopTimers()
        
        ; Create timer functions that check for concurrency
        this.checkTimer := () => this.SafeCheckMouse()
        this.updateTimer := () => this.SafeUpdateCursor()
        
        ; Start the timers
        SetTimer(this.checkTimer, Config.CheckInterval)
        SetTimer(this.updateTimer, Config.UpdateInterval)
    }
    
    StopTimers() {
        if (this.checkTimer) {
            SetTimer(this.checkTimer, 0)
            this.checkTimer := ""
        }
        if (this.updateTimer) {
            SetTimer(this.updateTimer, 0)
            this.updateTimer := ""
        }
        if (this.shrinkTimer) {
            SetTimer(this.shrinkTimer, 0)
            this.shrinkTimer := ""
        }
    }
    
    SafeCheckMouse() {
        global isCheckingMouse, lastCheckTime
        
        ; Prevent re-entry
        if (isCheckingMouse)
            return
            
        ; Check if enough time has passed
        now := A_TickCount
        if (now - lastCheckTime < Config.CheckInterval - 5)
            return
            
        isCheckingMouse := true
        lastCheckTime := now
        
        try {
            this.CheckMouse()
        } catch as err {
            ; Log error but don't crash
        }
        
        isCheckingMouse := false
    }
    
    SafeUpdateCursor() {
        global isUpdatingCursor, lastUpdateTime
        
        ; Prevent re-entry
        if (isUpdatingCursor)
            return
            
        ; Check if enough time has passed
        now := A_TickCount
        if (now - lastUpdateTime < Config.UpdateInterval - 5)
            return
            
        isUpdatingCursor := true
        lastUpdateTime := now
        
        try {
            this.UpdateCursor()
        } catch as err {
            ; Log error but don't crash
        }
        
        isUpdatingCursor := false
    }
    
    Reset() {
        this.movements := []
        this.lastDirection := ""
        this.directionChanges := 0
        this.totalDistance := 0
        this.wiggleStartTime := 0
        this.lastWiggleTime := 0
        
        this.leftMovement := 0
        this.rightMovement := 0
        this.upMovement := 0
        this.downMovement := 0
        this.horizontalChanges := []
    }
    
    CheckMouse() {
        if (!Config.Enabled)
            return
        
        ; Get mouse position with error handling
        try {
            MouseGetPos(&currentX, &currentY)
        } catch {
            return
        }
        
        deltaX := currentX - this.lastX
        deltaY := currentY - this.lastY
        distance := Sqrt(deltaX ** 2 + deltaY ** 2)
        
        ; Skip if no significant movement
        if (distance < 2) {
            if (isCurrentlyWiggling) {
                now := A_TickCount
                if (now - this.lastWiggleTime > 200) {
                    this.StopWiggling()
                }
            }
            this.lastX := currentX
            this.lastY := currentY
            return
        }
        
        now := A_TickCount
        
        ; Track movement directions
        if (deltaX > 0) {
            this.rightMovement += Abs(deltaX)
        } else if (deltaX < 0) {
            this.leftMovement += Abs(deltaX)
        }
        
        if (deltaY > 0) {
            this.downMovement += Abs(deltaY)
        } else if (deltaY < 0) {
            this.upMovement += Abs(deltaY)
        }
        
        ; Check for excessive single direction movement
        maxHorizontal := Max(this.leftMovement, this.rightMovement)
        maxVertical := Max(this.upMovement, this.downMovement)
        
        if (maxHorizontal > Config.MaxSingleDirection || maxVertical > Config.MaxSingleDirection) {
            if (!isCurrentlyWiggling) {
                this.Reset()
            } else {
                ; During wiggling, just reset counters but don't stop
                this.ResetCounters()
            }
            this.lastX := currentX
            this.lastY := currentY
            return
        }
        
        ; Detect direction changes (optimized)
        if (Abs(deltaX) >= Config.MinWiggleDistance / 10) {
            currentDirection := deltaX > 0 ? "right" : "left"
            
            if (this.lastDirection != "" && currentDirection != this.lastDirection) {
                this.directionChanges++
                this.horizontalChanges.Push({
                    direction: currentDirection,
                    distance: Abs(deltaX),
                    time: now
                })
            }
            
            this.lastDirection := currentDirection
        }
        
        ; Store movement
        this.movements.Push({
            x: currentX,
            y: currentY,
            time: now,
            distance: distance,
            deltaX: deltaX,
            deltaY: deltaY
        })
        
        ; Clean old movements
        while (this.movements.Length > 0 && now - this.movements[1].time > Config.TimeWindow) {
            this.movements.RemoveAt(1)
        }
        
        while (this.horizontalChanges.Length > 0 && now - this.horizontalChanges[1].time > Config.TimeWindow) {
            this.horizontalChanges.RemoveAt(1)
            if (this.directionChanges > 0) {
                this.directionChanges--
            }
        }
        
        ; Calculate total distance
        this.totalDistance := 0
        for movement in this.movements {
            this.totalDistance += movement.distance
        }
        
        ; Check for wiggle
        if (this.IsValidWiggle()) {
            if (!isCurrentlyWiggling) {
                this.StartWiggling()
            } else {
                this.ContinueWiggling()
            }
            this.lastWiggleTime := now
        } else if (isCurrentlyWiggling && now - this.lastWiggleTime > 100) {
            ; Don't stop immediately, give a grace period
            ; Wiggling will stop after the EnlargeDuration
        }
        
        this.lastX := currentX
        this.lastY := currentY
    }
    
    ResetCounters() {
        this.leftMovement := 0
        this.rightMovement := 0
        this.upMovement := 0
        this.downMovement := 0
        this.movements := []
        this.horizontalChanges := []
        this.directionChanges := 0
        this.totalDistance := 0
        this.lastDirection := ""
    }
    
    IsValidWiggle() {
        ; Basic checks first (fast)
        if (this.totalDistance < Config.WiggleThreshold)
            return false
        
        if (this.directionChanges < Config.MinWiggleCount)
            return false
        
        if (this.movements.Length < 5)
            return false
        
        ; Check for alternating pattern if required
        if (Config.RequireAlternating && this.horizontalChanges.Length >= 3) {
            isAlternating := true
            lastDir := ""
            
            for change in this.horizontalChanges {
                if (lastDir != "" && change.direction = lastDir) {
                    isAlternating := false
                    break
                }
                lastDir := change.direction
            }
            
            if (!isAlternating)
                return false
        }
        
        ; Check horizontal vs vertical movement
        totalHorizontal := this.leftMovement + this.rightMovement
        totalVertical := this.upMovement + this.downMovement
        
        if (totalHorizontal < totalVertical * 1.5) {
            return false
        }
        
        ; Additional detection modes (only if enabled for performance)
        if (Config.CircularWiggleDetection) {
            if (this.DetectCircularPattern())
                return true
        }
        
        if (Config.DiagonalWiggleDetection) {
            if (this.DetectDiagonalPattern())
                return true
        }
        
        return true
    }
    
    DetectCircularPattern() {
        ; Simplified circular detection (performance optimized)
        if (this.movements.Length < 8)
            return false
        
        ; Check if movement forms a rough circle
        angles := []
        for i, movement in this.movements {
            if (i > 1) {
                angle := ATan2(movement.deltaY, movement.deltaX)
                angles.Push(angle)
            }
        }
        
        ; Check for full rotation
        totalRotation := 0
        for i, angle in angles {
            if (i > 1) {
                diff := angle - angles[i-1]
                if (diff > 3.14159)
                    diff -= 6.28318
                else if (diff < -3.14159)
                    diff += 6.28318
                totalRotation += diff
            }
        }
        
        return Abs(totalRotation) > 3.14159  ; At least half circle
    }
    
    DetectDiagonalPattern() {
        ; Simplified diagonal detection
        if (this.movements.Length < 4)
            return false
        
        diagonalCount := 0
        for movement in this.movements {
            if (Abs(movement.deltaX) > 5 && Abs(movement.deltaY) > 5) {
                ratio := Abs(movement.deltaX) / Abs(movement.deltaY)
                if (ratio > 0.5 && ratio < 2.0) {
                    diagonalCount++
                }
            }
        }
        
        return diagonalCount >= this.movements.Length * 0.6
    }
    
    StartWiggling() {
        global targetCursorSize, isAnimating, isEnlarged, isCurrentlyWiggling, wiggleCount, currentWiggleSize, lastWiggleDetectionTime
        
        isCurrentlyWiggling := true
        wiggleCount := 1
        this.wiggleStartTime := A_TickCount
        lastWiggleDetectionTime := A_TickCount
        
        ; Clear any existing shrink timer
        if (this.shrinkTimer) {
            SetTimer(this.shrinkTimer, 0)
            this.shrinkTimer := ""
        }
        
        ; Calculate initial target in pixels
        if (Config.ChaosMode) {
            currentWiggleSize := Random(Config.RandomSizeMin, Config.RandomSizeMax)
        } else {
            currentWiggleSize := Config.EnlargeSize
        }
        
        ; Apply limits
        targetCursorSize := Max(ABSOLUTE_MIN_SIZE, Min(ABSOLUTE_MAX_SIZE, currentWiggleSize))
        
        isAnimating := true
        isEnlarged := true
    }
    
    ContinueWiggling() {
        global targetCursorSize, isCurrentlyWiggling, wiggleCount, currentWiggleSize, lastWiggleDetectionTime
        
        ; Check if enough time has passed since last growth (prevents too rapid growth)
        now := A_TickCount
        if (now - lastWiggleDetectionTime < 50) {
            return
        }
        
        isCurrentlyWiggling := true
        wiggleCount++
        lastWiggleDetectionTime := now
        
        ; Continuous growth while wiggling (in pixels)
        if (Config.ContinuousGrowth) {
            ; Increase the current wiggle size by the growth increment
            currentWiggleSize += Config.GrowthIncrement
            
            ; Apply maximum limit
            if (currentWiggleSize > Config.MaximumSize) {
                currentWiggleSize := Config.MaximumSize
            }
            
            ; Update target cursor size
            targetCursorSize := Max(ABSOLUTE_MIN_SIZE, Min(ABSOLUTE_MAX_SIZE, currentWiggleSize))
            
            ; Debug output (optional - remove in production)
            ; ToolTip("Wiggle Count: " . wiggleCount . "`nCurrent Size: " . currentWiggleSize . "px`nTarget: " . targetCursorSize . "px")
        }
    }
    
    StopWiggling() {
        global isCurrentlyWiggling, wiggleCount
        
        isCurrentlyWiggling := false
        wiggleCount := 0
        
        ; Clear any existing timer
        if (this.shrinkTimer) {
            SetTimer(this.shrinkTimer, 0)
            this.shrinkTimer := ""
        }
        
        ; Create a new shrink callback
        this.shrinkTimer := () => this.ShrinkAfterDelay()
        SetTimer(this.shrinkTimer, -Config.EnlargeDuration)
    }
    
    ShrinkAfterDelay() {
        global targetCursorSize, isEnlarged, isCurrentlyWiggling, currentWiggleSize
        
        if (!isCurrentlyWiggling) {
            targetCursorSize := Config.RestingSize
            isEnlarged := false
            currentWiggleSize := Config.RestingSize
        }
    }
    
    UpdateCursor() {
        global currentCursorSize, targetCursorSize, isAnimating, lastCursorUpdate, isCurrentlyWiggling
        
        ; If we're at target and not wiggling, nothing to do
        if (currentCursorSize = targetCursorSize && !isCurrentlyWiggling) {
            isAnimating := false
            return
        }
        
        now := A_TickCount
        if (now - lastCursorUpdate < 30) {
            return
        }
        
        diff := targetCursorSize - currentCursorSize
        
        ; Calculate animation speed based on whether growing or shrinking
        if (targetCursorSize > currentCursorSize) {
            ; Growing - use slower interpolation time
            animSpeed := 1000 / Config.InterpolationTime * Config.UpdateInterval / 1000
        } else {
            ; Shrinking - use shrink time
            animSpeed := 1000 / Config.ShrinkTime * Config.UpdateInterval / 1000
        }
        
        step := diff * animSpeed
        
        ; Smooth animation
        if (Abs(step) < 0.5) {
            currentCursorSize := targetCursorSize
        } else {
            currentCursorSize += step
        }
        
        ; Apply limits
        newSize := Round(currentCursorSize)
        newSize := Max(ABSOLUTE_MIN_SIZE, Min(ABSOLUTE_MAX_SIZE, newSize))
        
        ; Only update if size actually changed
        currentActualSize := GetCursorSize()
        if (newSize != currentActualSize) {
            try {
                SetCursorSize(newSize)
                lastCursorUpdate := now
            } catch {
                ; Ignore errors from cursor size changes
            }
        }
        
        if (Abs(currentCursorSize - targetCursorSize) < 0.5) {
            currentCursorSize := targetCursorSize
            if (!isCurrentlyWiggling) {
                isAnimating := false
            }
        }
    }
    
    Destroy() {
        this.StopTimers()
    }
}

; ==================== CURSOR FUNCTIONS ====================
GetCursorSize() {
    try {
        size := RegRead("HKCU\Control Panel\Cursors", "CursorBaseSize")
        return Integer(size)
    } catch {
        return 32
    }
}

SetCursorSize(size) {
    ; Allow any size within absolute limits
    if (size < ABSOLUTE_MIN_SIZE)
        size := ABSOLUTE_MIN_SIZE
    if (size > ABSOLUTE_MAX_SIZE)
        size := ABSOLUTE_MAX_SIZE
    
    try {
        ; Use Critical to prevent interruptions during registry operations
        Critical("On")
        RegWrite(size, "REG_DWORD", "HKCU\Control Panel\Cursors", "CursorBaseSize")
        DllCall("SystemParametersInfo", "UInt", 0x2029, "UInt", 0, "Ptr", size, "UInt", 0x01)
        DllCall("SystemParametersInfo", "UInt", 0x0057, "UInt", 0, "Ptr", 0, "UInt", 0)
        Critical("Off")
        return true
    } catch {
        Critical("Off")
        return false
    }
}

ResetCursor() {
    global currentCursorSize, targetCursorSize, isAnimating, isEnlarged, isCurrentlyWiggling, currentWiggleSize
    
    ; Use configurable reset size
    SetCursorSize(Config.ResetSize)
    currentCursorSize := Config.ResetSize
    targetCursorSize := Config.ResetSize
    currentWiggleSize := Config.ResetSize
    isAnimating := false
    isEnlarged := false
    isCurrentlyWiggling := false
}

InitializeBaseSizes() {
    global SYSTEM_ORIGINAL_SIZE, currentCursorSize, targetCursorSize, currentWiggleSize
    
    SYSTEM_ORIGINAL_SIZE := GetCursorSize()
    
    ; Apply minimum size limit
    if (Config.RestingSize < Config.MinimumSize)
        Config.RestingSize := Config.MinimumSize
    
    ; Apply absolute limits
    if (Config.RestingSize < ABSOLUTE_MIN_SIZE)
        Config.RestingSize := ABSOLUTE_MIN_SIZE
    if (Config.RestingSize > ABSOLUTE_MAX_SIZE)
        Config.RestingSize := ABSOLUTE_MAX_SIZE
    
    currentCursorSize := Config.RestingSize
    targetCursorSize := Config.RestingSize
    currentWiggleSize := Config.RestingSize
    
    if (Config.RestingSize != SYSTEM_ORIGINAL_SIZE) {
        SetCursorSize(Config.RestingSize)
    }
}

; ==================== CONFIGURATION GUI ====================
ShowConfigGui(*) {
    configGui := Gui("+Resize", "Mouse Wiggle Enlarger - Configuration")
    configGui.MarginX := 15
    configGui.MarginY := 15
    
    ; Tab control
    tabs := configGui.Add("Tab3", "w500 h550", ["Basic Detection", "Advanced Detection", "Display", "Animation", "Visual Effects", "Performance", "System"])
    
    ; Helper function to get numeric value from control
    GetNumericValue(ctrl, defaultVal := 0, isFloat := false) {
        text := ctrl.Text
        if (text = "")
            return defaultVal
        
        try {
            if (isFloat)
                return Float(text)
            else
                return Integer(text)
        } catch {
            return defaultVal
        }
    }
    
    ; ==================== BASIC DETECTION TAB ====================
    tabs.UseTab(1)
    
    configGui.Add("Text", "Section", "Basic Wiggle Detection")
    
    configGui.Add("Text", "xs y+15", "Total Movement Required (pixels):")
    thresholdEdit := configGui.Add("Edit", "xs w100 Number", Config.WiggleThreshold)
    configGui.Add("Text", "x+10", "Default: 350, Range: 100-2000")
    
    configGui.Add("Text", "xs y+15", "Detection Window (milliseconds):")
    timeEdit := configGui.Add("Edit", "xs w100 Number", Config.TimeWindow)
    configGui.Add("Text", "x+10", "Default: 750, Range: 100-2000")
    
    configGui.Add("Text", "xs y+15", "Minimum Direction Changes:")
    wiggleEdit := configGui.Add("Edit", "xs w100 Number", Config.MinWiggleCount)
    configGui.Add("Text", "x+10", "Default: 3, Range: 2-10")
    
    configGui.Add("Text", "xs y+15", "Minimum Wiggle Distance (pixels):")
    minDistEdit := configGui.Add("Edit", "xs w100 Number", Config.MinWiggleDistance)
    configGui.Add("Text", "x+10", "Default: 30, Range: 5-200")
    
    configGui.Add("Text", "xs y+15", "Max Single Direction Movement (pixels):")
    maxDirEdit := configGui.Add("Edit", "xs w100 Number", Config.MaxSingleDirection)
    configGui.Add("Text", "x+10", "Default: 500, Range: 100-1000")
    
    alternateCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.RequireAlternating,
        "Require alternating left-right movement")
    
    ; ==================== ADVANCED DETECTION TAB ====================
    tabs.UseTab(2)
    
    configGui.Add("Text", "Section", "Advanced Detection Options (Performance Impact)")
    
    circularCheck := configGui.Add("CheckBox", "xs y+15 Checked" . Config.CircularWiggleDetection,
        "Enable Circular Wiggle Detection (CPU Intensive)")
    configGui.Add("Text", "xs", "Detects circular mouse movements as wiggles")
    
    diagonalCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.DiagonalWiggleDetection,
        "Enable Diagonal Wiggle Detection (CPU Intensive)")
    configGui.Add("Text", "xs", "Detects diagonal patterns as wiggles")
    
    configGui.Add("Text", "xs y+20", "Pattern Memory (movements):")
    patternEdit := configGui.Add("Edit", "xs w100 Number", Config.PatternMemory)
    configGui.Add("Text", "x+10", "Default: 5, Range: 1-20")
    
    adaptiveCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.AdaptiveSensitivity,
        "Adaptive Sensitivity (CPU Intensive)")
    configGui.Add("Text", "xs", "Automatically adjusts sensitivity based on usage patterns")
    
    ; ==================== DISPLAY TAB ====================
    tabs.UseTab(3)
    
    configGui.Add("Text", "Section", "Cursor Size Settings (in PIXELS)")
    
    configGui.Add("Text", "xs y+15", "Resting Size (when not wiggling) px:")
    restingEdit := configGui.Add("Edit", "xs w100 Number", Config.RestingSize)
    configGui.Add("Text", "x+10", "Default: 32, Range: 1-256")
    
    configGui.Add("Text", "xs y+20", "Minimum Size (smallest allowed) px:")
    minSizeEdit := configGui.Add("Edit", "xs w100 Number", Config.MinimumSize)
    configGui.Add("Text", "x+10", "Default: 1, Range: 1-32")
    
    configGui.Add("Text", "xs y+20", "Enlarge Size (when wiggling) px:")
    enlargeEdit := configGui.Add("Edit", "xs w100 Number", Config.EnlargeSize)
    configGui.Add("Text", "x+10", "Default: 64, Range: 1-32768")
    
    configGui.Add("Text", "xs y+20", "Maximum Size Limit px:")
    maxSizeEdit := configGui.Add("Edit", "xs w100 Number", Config.MaximumSize)
    configGui.Add("Text", "x+10", "Default: 256, Range: 32-32768")
    
    configGui.Add("Text", "xs y+20", "Reset Size (for reset command) px:")
    resetEdit := configGui.Add("Edit", "xs w100 Number", Config.ResetSize)
    configGui.Add("Text", "x+10", "Default: 32, Range: 1-256")
    
    maintainMaxCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.MaintainMaxWhileWiggling,
        "Keep max size during continuous wiggling")
    
    continuousCheck := configGui.Add("CheckBox", "xs y+10 Checked" . Config.ContinuousGrowth,
        "Continuously grow while wiggling")
    
    configGui.Add("Text", "xs y+10", "Growth Increment (pixels per wiggle):")
    growthIncrementEdit := configGui.Add("Edit", "xs w100 Number", Config.GrowthIncrement)
    configGui.Add("Text", "x+10", "Default: 2, Range: 1-50")
    
    configGui.Add("Text", "xs y+20", "Hold Duration after wiggle stops (ms):")
    holdEdit := configGui.Add("Edit", "xs w100 Number", Config.EnlargeDuration)
    configGui.Add("Text", "x+10", "Default: 500, Range: 0-5000")
    
    ; ==================== ANIMATION TAB ====================
    tabs.UseTab(4)
    
    configGui.Add("Text", "Section", "Animation Settings")
    
    configGui.Add("Text", "xs y+15", "Growth Time (milliseconds):")
    growthEdit := configGui.Add("Edit", "xs w100 Number", Config.InterpolationTime)
    configGui.Add("Text", "x+10", "Default: 800, Range: 50-3000")
    
    configGui.Add("Text", "xs y+20", "Shrink Time (milliseconds):")
    shrinkEdit := configGui.Add("Edit", "xs w100 Number", Config.ShrinkTime)
    configGui.Add("Text", "x+10", "Default: 1000, Range: 50-3000")
    
    smoothCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.SmoothShrink,
        "Smooth shrink animation")
    
    ; ==================== VISUAL EFFECTS TAB ====================
    tabs.UseTab(5)
    
    configGui.Add("Text", "Section", "Visual Effects (Performance Impact)")
    
    pulseCheck := configGui.Add("CheckBox", "xs y+15 Checked" . Config.PulseOnWiggle,
        "Pulse effect while wiggling (CPU Intensive)")
    
    configGui.Add("Text", "xs y+10", "Pulse Speed (milliseconds):")
    pulseSpeedEdit := configGui.Add("Edit", "xs w100 Number", Config.PulseSpeed)
    configGui.Add("Text", "x+10", "Default: 500")
    
    rainbowCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.RainbowMode,
        "Rainbow Mode (changes size continuously)")
    
    chaosCheck := configGui.Add("CheckBox", "xs y+20 Checked" . Config.ChaosMode,
        "Chaos Mode (random sizes)")
    
    configGui.Add("Text", "xs y+20", "Chaos Mode - Random Size Min (px):")
    randomMinEdit := configGui.Add("Edit", "xs w100 Number", Config.RandomSizeMin)
    configGui.Add("Text", "x+10", "Default: 16")
    
    configGui.Add("Text", "xs y+10", "Chaos Mode - Random Size Max (px):")
    randomMaxEdit := configGui.Add("Edit", "xs w100 Number", Config.RandomSizeMax)
    configGui.Add("Text", "x+10", "Default: 128")
    
    ; ==================== PERFORMANCE TAB ====================
    tabs.UseTab(6)
    
    configGui.Add("Text", "Section", "Performance Settings")
    
    configGui.Add("Text", "xs y+15", "Check Interval (milliseconds):")
    checkEdit := configGui.Add("Edit", "xs w100 Number", Config.CheckInterval)
    configGui.Add("Text", "x+10", "Default: 30, Range: 10-100")
    
    configGui.Add("Text", "xs y+20", "Update Interval (milliseconds):")
    updateEdit := configGui.Add("Edit", "xs w100 Number", Config.UpdateInterval)
    configGui.Add("Text", "x+10", "Default: 50, Range: 20-200")
    
    configGui.Add("Text", "xs y+30", "⚠️ Lower values = smoother but more CPU usage")
    configGui.Add("Text", "xs y+10", "⚡ Higher values = less smooth but better performance")
    
    ; ==================== SYSTEM TAB ====================
    tabs.UseTab(7)
    
    configGui.Add("Text", "Section", "System Information")
    
    configGui.Add("Text", "xs y+10", "Original System Cursor Size: " . SYSTEM_ORIGINAL_SIZE . " px")
    configGui.Add("Text", "xs y+5", "Current Resting Size: " . Config.RestingSize . " px")
    configGui.Add("Text", "xs y+5", "Current Actual Size: " . GetCursorSize() . " px")
    configGui.Add("Text", "xs y+5", "Current Target Size: " . targetCursorSize . " px")
    configGui.Add("Text", "xs y+5", "Current Wiggle Size: " . currentWiggleSize . " px")
    configGui.Add("Text", "xs y+5", "Wiggle Count: " . wiggleCount)
    configGui.Add("Text", "xs y+5", "Is Wiggling: " . (isCurrentlyWiggling ? "Yes" : "No"))
    configGui.Add("Text", "xs y+5", "Absolute Minimum: " . ABSOLUTE_MIN_SIZE . " px")
    configGui.Add("Text", "xs y+5", "Absolute Maximum: " . ABSOLUTE_MAX_SIZE . " px")
    
    configGui.Add("Text", "xs y+20", "Testing & Debug")
    
    testBtn := configGui.Add("Button", "xs w150", "Test Enlarge (2 sec)")
    TestEnlarge() {
        global targetCursorSize, isAnimating, currentWiggleSize
        testSize := GetNumericValue(enlargeEdit, 64)
        currentWiggleSize := testSize
        targetCursorSize := Max(ABSOLUTE_MIN_SIZE, Min(ABSOLUTE_MAX_SIZE, testSize))
        isAnimating := true
        
        SetTimer(RestoreFromTest, -2000)
    }
    testBtn.OnEvent("Click", (*) => TestEnlarge())
    
    resetBtn := configGui.Add("Button", "xs y+10 w150", "Reset to Config Size")
    resetBtn.OnEvent("Click", (*) => ResetCursor())
    
    ; ==================== END TABS ====================
    tabs.UseTab()
    
    ; Bottom buttons
    btnY := 580
    btnSave := configGui.Add("Button", "x15 y" . btnY . " w90", "&Save")
    btnCancel := configGui.Add("Button", "x+10 w90", "&Cancel")
    btnDefaults := configGui.Add("Button", "x+10 w90", "&Defaults")
    
    OnSave(*) {
        global wiggleDetectorInstance, targetCursorSize, currentWiggleSize
        
        ; Update configuration with values from controls
        Config.WiggleThreshold := Min(Max(GetNumericValue(thresholdEdit), 100), 2000)
        Config.TimeWindow := Min(Max(GetNumericValue(timeEdit), 100), 2000)
        Config.MinWiggleCount := Min(Max(GetNumericValue(wiggleEdit), 2), 10)
        Config.MinWiggleDistance := Min(Max(GetNumericValue(minDistEdit), 5), 200)
        Config.MaxSingleDirection := Min(Max(GetNumericValue(maxDirEdit), 100), 1000)
        Config.RequireAlternating := alternateCheck.Value
        
        Config.CircularWiggleDetection := circularCheck.Value
        Config.DiagonalWiggleDetection := diagonalCheck.Value
        Config.PatternMemory := Min(Max(GetNumericValue(patternEdit), 1), 20)
        Config.AdaptiveSensitivity := adaptiveCheck.Value
        
        ; Save pixel-based settings
        Config.RestingSize := Min(Max(GetNumericValue(restingEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.MinimumSize := Min(Max(GetNumericValue(minSizeEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.EnlargeSize := Min(Max(GetNumericValue(enlargeEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.MaximumSize := Min(Max(GetNumericValue(maxSizeEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.ResetSize := Min(Max(GetNumericValue(resetEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.MaintainMaxWhileWiggling := maintainMaxCheck.Value
        Config.ContinuousGrowth := continuousCheck.Value
        Config.GrowthIncrement := Min(Max(GetNumericValue(growthIncrementEdit), 1), 50)
        Config.EnlargeDuration := Min(Max(GetNumericValue(holdEdit), 0), 10000)
        
        Config.InterpolationTime := Min(Max(GetNumericValue(growthEdit), 50), 5000)
        Config.ShrinkTime := Min(Max(GetNumericValue(shrinkEdit), 50), 5000)
        Config.SmoothShrink := smoothCheck.Value
        
        Config.PulseOnWiggle := pulseCheck.Value
        Config.PulseSpeed := Min(Max(GetNumericValue(pulseSpeedEdit), 100), 2000)
        Config.RainbowMode := rainbowCheck.Value
        Config.ChaosMode := chaosCheck.Value
        Config.RandomSizeMin := Min(Max(GetNumericValue(randomMinEdit), 1), ABSOLUTE_MAX_SIZE)
        Config.RandomSizeMax := Min(Max(GetNumericValue(randomMaxEdit), 1), ABSOLUTE_MAX_SIZE)
        
        Config.CheckInterval := Min(Max(GetNumericValue(checkEdit), 10), 100)
        Config.UpdateInterval := Min(Max(GetNumericValue(updateEdit), 20), 200)
        
        Config.Save()
        
        InitializeBaseSizes()
        
        targetCursorSize := Config.RestingSize
        currentWiggleSize := Config.RestingSize
        
        if (IsObject(wiggleDetectorInstance)) {
            wiggleDetectorInstance.Destroy()
        }
        wiggleDetectorInstance := WiggleDetector()
        
        configGui.Destroy()
    }
    
    OnDefaults(*) {
        ; Reasonable defaults with pixel-based sizes
        thresholdEdit.Text := "350"
        timeEdit.Text := "750"
        wiggleEdit.Text := "3"
        minDistEdit.Text := "30"
        maxDirEdit.Text := "500"
        alternateCheck.Value := true
        
        restingEdit.Text := "32"
        minSizeEdit.Text := "1"
        enlargeEdit.Text := "64"
        maxSizeEdit.Text := "256"
        resetEdit.Text := "32"
        maintainMaxCheck.Value := true
        continuousCheck.Value := true
        growthIncrementEdit.Text := "2"
        holdEdit.Text := "500"
        
        growthEdit.Text := "800"
        shrinkEdit.Text := "1000"
        smoothCheck.Value := true
        
        circularCheck.Value := false
        diagonalCheck.Value := false
        patternEdit.Text := "5"
        adaptiveCheck.Value := false
        
        pulseCheck.Value := false
        pulseSpeedEdit.Text := "500"
        rainbowCheck.Value := false
        chaosCheck.Value := false
        randomMinEdit.Text := "16"
        randomMaxEdit.Text := "128"
        
        checkEdit.Text := "30"
        updateEdit.Text := "50"
    }
    
    btnSave.OnEvent("Click", OnSave)
    btnCancel.OnEvent("Click", (*) => configGui.Destroy())
    btnDefaults.OnEvent("Click", OnDefaults)
    
    configGui.Show("w530 h650")
}

; Fixed callback for test enlarge
RestoreFromTest() {
    global targetCursorSize, currentWiggleSize
    targetCursorSize := Config.RestingSize
    currentWiggleSize := Config.RestingSize
}

; ==================== TRAY MENU ====================
A_TrayMenu.Delete()

A_TrayMenu.Add("&Configuration", ShowConfigGui)
A_TrayMenu.Add()

ToggleDetection() {
    Config.Enabled := !Config.Enabled
    Config.Save()
    A_TrayMenu.ToggleCheck("&Enable Detection")
    
    if (Config.Enabled) {
    } else {
        global targetCursorSize := Config.RestingSize
    }
}
A_TrayMenu.Add("&Enable Detection", (*) => ToggleDetection())

if (Config.Enabled)
    A_TrayMenu.Check("&Enable Detection")

TestEnlargeMenu() {
    global targetCursorSize, isAnimating, currentWiggleSize
    currentWiggleSize := Config.EnlargeSize
    targetCursorSize := Max(ABSOLUTE_MIN_SIZE, Min(ABSOLUTE_MAX_SIZE, Config.EnlargeSize))
    isAnimating := true

    SetTimer(RestoreFromTest, -2000)
}
A_TrayMenu.Add("&Test Enlarge", (*) => TestEnlargeMenu())

A_TrayMenu.Add("&Reset to Config Size", (*) => ResetCursor())
A_TrayMenu.Add()

; Quick Settings Menu
quickMenu := Menu()

SetSize(pixels) {
    Config.EnlargeSize := pixels
    Config.Save()
}

quickMenu.Add("Wiggle Size 32px", (*) => SetSize(32))
quickMenu.Add("Wiggle Size 48px", (*) => SetSize(48))
quickMenu.Add("Wiggle Size 64px", (*) => SetSize(64))
quickMenu.Add("Wiggle Size 96px", (*) => SetSize(96))
quickMenu.Add("Wiggle Size 128px", (*) => SetSize(128))
quickMenu.Add("Wiggle Size 256px", (*) => SetSize(256))
quickMenu.Add("Wiggle Size 512px", (*) => SetSize(512))
quickMenu.Add("Wiggle Size 1024px", (*) => SetSize(1024))

A_TrayMenu.Add("&Quick Settings", quickMenu)
A_TrayMenu.Add()

ShowAbout() {
    global wiggleCount, currentWiggleSize, isCurrentlyWiggling
    MsgBox("Mouse Wiggle Enlarger v3.1`n`n" .
        "Features:`n" .
        "• Pixel-based size configuration`n" .
        "• Continuous growth while wiggling`n" .
        "• Smooth, slow animations`n" .
        "• Performance optimized`n" .
        "• Configurable reset size`n`n" .
        "Hotkeys:`n" .
        "Ctrl+Shift+R: Reset to configured size (" . Config.ResetSize . "px)`n" .
        "Ctrl+Shift+E: Toggle enable`n" .
        "Ctrl+Shift+C: Configuration`n" .
        "Ctrl+Shift+D: Show debug info`n`n" .
        "System cursor size: " . SYSTEM_ORIGINAL_SIZE . " px`n" .
        "Current resting size: " . Config.RestingSize . " px`n" .
        "Current actual size: " . GetCursorSize() . " px`n" .
        "Current wiggle size: " . currentWiggleSize . " px`n" .
        "Wiggle count: " . wiggleCount . "`n" .
        "Is wiggling: " . (isCurrentlyWiggling ? "Yes" : "No"), "About", 0x40)
}
A_TrayMenu.Add("&About", (*) => ShowAbout())

ExitAppr() {
    global wiggleDetectorInstance
    if (IsObject(wiggleDetectorInstance)) {
        wiggleDetectorInstance.Destroy()
    }
    ResetCursor()
    Config.Save()
    ExitApp()
}
A_TrayMenu.Add("E&xit", (*) => ExitAppr())

; ==================== HOTKEYS ====================
^+r:: ResetCursor()

^+c:: ShowConfigGui()

^+e:: ToggleDetection()

; Debug hotkey to show current state
^+d:: {
    global wiggleCount, currentWiggleSize, isCurrentlyWiggling, targetCursorSize
    ToolTip("Debug Info:`n" .
        "Wiggling: " . (isCurrentlyWiggling ? "Yes" : "No") . "`n" .
        "Wiggle Count: " . wiggleCount . "`n" .
        "Current Size: " . GetCursorSize() . "px`n" .
        "Target Size: " . targetCursorSize . "px`n" .
        "Wiggle Size: " . currentWiggleSize . "px`n" .
        "Growth Enabled: " . (Config.ContinuousGrowth ? "Yes" : "No") . "`n" .
        "Growth Increment: " . Config.GrowthIncrement . "px")
    SetTimer(() => ToolTip(), -3000)
}

; ==================== STARTUP ====================
Config.Load()
InitializeBaseSizes()
wiggleDetectorInstance := WiggleDetector()

A_IconTip := "Mouse Wiggle Enlarger`nRight-click for options"

; Helper function for ATan2 (not built-in to AHK v2)
ATan2(y, x) {
    return DllCall("msvcrt\atan2", "Double", y, "Double", x, "Double")
}